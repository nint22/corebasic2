<html>
<head>
<title>cBasic - Programming Language</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
</head>
<body>

 <h1><a name="Introduction"></a>Introduction to coreBasic<a href="#Introduction" class="section_anchor"></a></h1><p>CoreBasic, or cBasic, is an <a href="http://en.wikipedia.org/wiki/Imperative_programming" rel="nofollow">imperative</a> and <a href="http://en.wikipedia.org/wiki/Procedural_programming" rel="nofollow">procedural</a> programming language that is similar to <a href="http://en.wikipedia.org/wiki/BASIC" rel="nofollow">BASIC</a>-like syntax, but more closely resembles <a href="http://en.wikipedia.org/wiki/TI-BASIC" rel="nofollow">TI-Basic</a>. The type system is dynamic and implied, meaning that there are four major types (int, float, bool, and string), but variables are assigned the implied type. For example, if the user writes &quot;a = 1&quot;, it is implied that the variable &#x27;a&#x27; is an integer, while if the user writes &quot;a = 1.0&quot; then it is implied that variable &#x27;a&#x27; is a float. </p><p>To keep the language clean and simple, to meet the target goal of &quot;easy to learn and developed for academic purposes&quot;, advanced features like multi-threading, object-oriented programming, and duck-typing is not supported, though can be added through extension of the current code base. </p><h2><a name="Structure"></a>Structure<a href="#Structure" class="section_anchor"></a></h2><p>The language resembles imperative block-like syntax. Each line should be a valid single expression. Operators, functions, and keywords can be stacked, meaning that a variable can be assigned the results of a function, in which function arguments contain expressions. Note that blocks are never defined by the C-style curly-braces, but simply by block-keywords (such as for, while, if, etc..) and the &quot;end&quot; keyword. </p><p>Internally, the code is parsed using the <a href="http://en.wikipedia.org/wiki/Shunting-yard_algorithm" rel="nofollow">Shunting-yard Algorithm</a> into <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" rel="nofollow">Reverse Polish notation</a> which helps during execution and code verification. </p><h2><a name="Data_Types"></a>Data Types<a href="#Data_Types" class="section_anchor"></a></h2><p>There are only four data types: </p><ul><li>Integers: signed whole numbers, that are the size of the host system&#x27;s word size (i.e. a 32-bit architecture will allow for a 32-bit signed integer) </li><li>Floats: signed floating-point (decimal) values, that are the size of the host system&#x27;s word size </li><li>Boolean: either a true or false statement, which is represented as an integer: false is always 0, while true is any other value </li><li>String: an array of characters that are null terminated (internally, strings themselves are always stored in the data section of a program, while the variable itself acts as a pointer to this data). Note that string-concatenation is not a feature of this language </li></ul><h2><a name="Comments"></a>Comments<a href="#Comments" class="section_anchor"></a></h2><p>C-style double-slash comments are allowed on any line. Any comment at the end of a line of code is ignored, while the code itself is left alone. Lines with comments are ignored and removed entirely. </p><p>Slash-star comments (i.e. <tt>/* C-style slash-star comment */</tt>) are not allowed. </p><h2><a name="Key_Words"></a>Key Words<a href="#Key_Words" class="section_anchor"></a></h2><p><i>Reserved, but private: &quot;loaddata&quot;, &quot;loadvar&quot;, &quot;addstack&quot;</i> </p><ul><li><strong>if(&lt;boolean expression&gt;)</strong> </li><ul><li>If the expression is true, execute the code within the associated block and go to the end of the if/else group, else, continue the flow of execution </li></ul></ul><p><i>Example:</i> </p><pre class="prettyprint">if(input() &lt;= 10)
  disp(&quot;You must input a number greater than 10!&quot;)
end</pre><ul><li><strong>elif(&lt;boolean expression&gt;)</strong> </li><ul><li>If the expression is true, execute the code within the associate block and go to the end of the if/else group, else, continue the flow of execution </li></ul></ul><p><i>Example:</i> </p><pre class="prettyprint">if(x &lt; 10)
  disp(&quot;X is smaller than 10&quot;)
elif(x &lt; 20)
  disp(&quot;X is smaller than 20&quot;)
end</pre><ul><li><strong>else</strong> </li><ul><li>The conditional block that is always executed in an if/else group if no other conditional case is met </li></ul></ul><p><i>Example:</i> </p><pre class="prettyprint">if(x &lt; 10)
  disp(&quot;X is smaller than 10&quot;)
else
  disp(&quot;X is equal to, or greater, than 10&quot;)
end</pre><ul><li><strong>for(&lt;iteration variable&gt;, &lt;initial value expression, inclusive&gt;, &lt;max value expression, inclusive&gt;, &lt;increment expression&gt;)</strong> </li><ul><li>Loops through the code associated with this block, iterating with the given variable, starting with an initial value given, and goes up to the maximum value given (inclusive). Each loop increases the iterating variable by the given amount </li></ul></ul><p><i>Example:</i> </p><pre class="prettyprint">for(i, 1, 10, 1)
  disp(&quot;Var i: &quot;)
  disp(i)
  disp(&quot;\n&quot;)
end</pre><ul><li><strong>while(&lt;boolean expression&gt;)</strong> </li><ul><li>Loops through the code associated with this block until the given boolean expresion is false </li></ul></ul><p><i>Example:</i> </p><pre class="prettyprint">i = 1
while(i &lt;= 10)
  disp(&quot;Var i: &quot;)
  disp(i)
  disp(&quot;\n&quot;)
  i = i + 1
end</pre><ul><li><strong>end</strong> </li><ul><li>Defines the end of a conditional or loop block. </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">while(a &lt; 5)
  // Do something...
end</pre><ul><li><strong>pause</strong> </li><ul><li>Interrupts the application and pauses the flow of execution until there is any key-press from the user </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">disp(&quot;Press any key to continue...&quot;)
pause</pre><ul><li><strong>label &lt;label name&gt;</strong> </li><ul><li>A label that can be jumped to using the <i>goto</i> keyword </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">label sample
// This is an example of an infinite while-loop
goto sample</pre><ul><li><strong>goto &lt;label name&gt;</strong> </li><ul><li>Jumps to a given label name </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">label sample
// This is an example of an infinite while-loop
goto sample</pre><ul><li><strong>exec &lt;function name&gt;</strong> </li><ul><li><i>Not yet defined</i> </li></ul></ul><ul><li><strong>return &lt;value expression&gt;</strong> </li><ul><li><i>Not yet defined</i> </li></ul></ul><ul><li><strong>stop</strong> </li><ul><li>Halts the simulation / process, which flags the process as correctly complete, and not halted because of an error </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">// Done with the code, stop the program
stop</pre><ul><li><strong>input</strong> </li><ul><li>Returns any and all user input as the best fitting type. If the user were to type an integer, it is cast to an integer, while if the user types an alpha-numeric string, it is returned as a string type </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">a = input()
disp(&quot;You wrote: &quot;)
disp(a)</pre><ul><li><strong>disp(&lt;literal, variable, or expression&gt;)</strong> </li><ul><li>Print out the given literal, variable, or expression </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">disp(&quot;Hello, World!\n&quot;)</pre><ul><li><strong>output <i>undefined</i></strong> </li><ul><li><i>Not yet defined</i> </li></ul></ul><ul><li><strong>getKey</strong> </li><ul><li>Returns a single character read from the user input stream </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">key = getKey()
disp(&quot;You pressed: &quot;)
disp(key)</pre><ul><li><strong>clear</strong> </li><ul><li>Clear all output, including the text and screen output buffers </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">// Clear screen
clear()</pre><ul><li><strong>func &lt;function name&gt;</strong> </li><ul><li>Define a function and the arguments </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">func add_one(int x)
  return x + 1
end</pre><ul><li><strong>=</strong> </li><ul><li>Set operator </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">variable = 10</pre><ul><li><strong>+</strong> </li><ul><li>Addition operator </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">variable = 1 + 2</pre><ul><li><strong>-</strong> </li><ul><li>Subtraction operator </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">variable = 1 - 2</pre><ul><li><strong><tt>*</tt></strong> </li><ul><li>Multiplication operator </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">variable = 1 * 2</pre><ul><li><strong>/</strong> </li><ul><li>Division operator </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">variable = 1 / 2</pre><ul><li><strong>%</strong> </li><ul><li>Modulo (remainder) operator </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">variable = 1 % 2</pre><ul><li><strong><tt>==</tt></strong> </li><ul><li>Equivalence operator; note that certain variables will change type as needed. Integers and booleans will become interchangeable, while a floating-point variable will round-down to an integer </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">if(a == b)
  disp(&quot;Variable A is equal to B&quot;)
end</pre><ul><li><strong>!=</strong> </li><ul><li>Non-equivalence operator; note that this follows the same casting rules as the equivalence operator </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">if(a == b)
  disp(&quot;Variable A is not equal to B&quot;)
end</pre><ul><li><strong>&gt;</strong> </li><ul><li>Greater-than operator; note that this follows the same casting rules as the equivalence operator </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">if(a &gt; b)
  disp(&quot;Variable A larger than B&quot;)
end</pre><ul><li><strong>&gt;=</strong> </li><ul><li>Greater-than-or-equal operator; note that this follows the same casting rules as the equivalence operator </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">if(a &gt; b)
  disp(&quot;Variable A larger than or equal B&quot;)
end</pre><ul><li><strong>&lt;</strong> </li><ul><li>Smaller-than operator; note that this follows the same casting rules as the equivalence operator </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">if(a &lt; b)
  disp(&quot;Variable A less than B&quot;)
end</pre><ul><li><strong>&lt;=</strong> </li><ul><li>Smaller-than-or-equal operator; note that this follows the same casting rules as the equivalence operator </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">if(a &gt; b)
  disp(&quot;Variable A less than or equal to B&quot;)
end</pre><ul><li><strong>! &lt;boolean | integer | expression&gt;</strong> </li><ul><li>Logical not operator </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">a = true
a = !a
// A will now always be false</pre><ul><li><strong>&lt;variable | expression&gt; and &lt;variable | expression&gt;</strong> </li><ul><li>Logical and </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">if(a and b)
  disp(&quot;A and B are set to true&quot;)
end</pre><ul><li><strong>&lt;variable | expression&gt; or &lt;variable | expression&gt;</strong> </li><ul><li>Logical or </li></ul></ul><p><i>Example</i> </p><pre class="prettyprint">if(a or b)
  disp(&quot;A or B are set to true&quot;)
end</pre><h2><a name="Formal_Language_Definition"></a>Formal Language Definition<a href="#Formal_Language_Definition" class="section_anchor"></a></h2><p><i>The following is a simplified / informal <a href="http://en.wikipedia.org/wiki/Context-free_grammar" rel="nofollow">Context-free grammar</a> description of the cBasic language</i> </p><p>Let S be any given string within a valid program of cBasic, delimited by a space character; accepted characters for the entire language are all ASCII alpha-numeric. Unicode / wide-characters are not supported. A string S may be empty. Function arguments are delimited by commas (&#x27;,&#x27;). </p><ul><li>S → {&#x27;a&#x27; - &#x27;z&#x27; | &#x27;A&#x27; - &#x27;Z&#x27; | &#x27;0&#x27; - &#x27;9&#x27;} </li><li>S → SS </li><li>S → {<i>empty set</i>} </li></ul><p>Math rules: </p><ul><li>S → (S) </li><li>S → S + S </li><li>S → S - S </li><li>S → S <tt>*</tt> S </li><li>S → S / S </li><li>S → S % S </li></ul><p>Boolean comparisons: </p><ul><li>S → S &lt; S </li><li>S → S &lt;= S </li><li>S → S &gt; S </li><li>S → S &gt;= S </li><li>S → S == S </li><li>S → S != S </li><li>S → !S </li><li>S → S = S </li></ul><p>Keyword-specific rules </p><ul><li>S → if(S) line S line end </li><li>S → elif(S) line E </li><li>E → else s line end </li><li>S → while(S) line S line end </li><li>S → for(S, S, S, S) line S line end </li><li>S → disp(S) </li><li>S → exec S(S) </li><li>S → input() </li><li>S → pause() </li><li>S → label S: </li><li>S → goto S </li></ul>

 <h1><a name="cBasic_Virtual_Machine_Description"></a>cBasic Virtual Machine Description<a href="#cBasic_Virtual_Machine_Description" class="section_anchor"></a></h1>
 <p>coreBasic, or &quot;cBasic&quot; for short, runs in a sort of <a href="http://en.wikipedia.org/wiki/Virtual_machine" rel="nofollow">Virtual Machine</a>, which is an isolated (sandbox) process that executes only a set of pre-defined instructions, similar to assembly language, from a given cBasic program. This program can only manipulate certain segments of memory in this process, specifically just the memory allocated by the VM for the cBasic program. If the cBasic program ever attempts to reach for memory addresses outside of the Virtual Machine, the simulation is halted and killed. </p><p>Note that in the documentation and source code itself, the term &quot;Virtual Machine&quot;, &quot;simulation&quot;, and &quot;process&quot; are all used interchangeably, though are remarkably different in other applications. Since the cBasic run-time only does software-emulation of a virtual computer architecture (i.e. does not do <a href="http://en.wikipedia.org/wiki/Hardware_virtualization" rel="nofollow">hardware virtualization</a>), it can be more correctly described as a simulation. The term virtual machine is used when describing the code that executes this software-emulation, while the simulation describes the system as a whole, and the process is the implementation environment of the simulation. </p>
 <h2><a name="cBasic_Processor"></a>cBasic Processor<a href="#cBasic_Processor" class="section_anchor"></a></h2><p>The cBasic processor is a simple single-instruction pipeline architecture that fetches an instruction based on the current instruction pointer (i.e. instruction counter), executes this instruction, then places the results on the stack. There are only a few &quot;registers&quot; (which are variables in the &quot;cbProcessor&quot; data structure) in each VM processor. All memory-manipulation is done on a stack that grows from a high-to-low address scheme, and generally does all operators in a <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" rel="nofollow">Reverse Polish notation</a> method. This means that to compute the expression &quot;4 + 3&quot;, the stack has the literals &quot;4&quot; and &quot;3&quot;, pushed, then the instruction &quot;+&quot; is executed, popping off both those elements, and pushing the result of &quot;7&quot;. </p><h2><a name="cBasic_Registers"></a>cBasic Registers<a href="#cBasic_Registers" class="section_anchor"></a></h2><p><i>Note that all registers are of &quot;size_t&quot;, usually defined as an &quot;unsigned long&quot; by your C compiler implementation and host operating system / host processor word-size.</i> </p><ul><li><strong>Stack Pointer</strong> - The address of the start of the current stack frame </li><li><strong>Stack Base Pointer</strong> - The address of the base of the current stack frame </li><li><strong>Screen Pointer</strong> - The starting address of the screen-memory allocation </li><li><strong>Data Pointer</strong> - The starting address of all static data </li><li><strong>Instruction Pointer</strong> - The address of the current instruction the processor is executing </li><li><strong>Ticks</strong> - The total number of instructions executed </li></ul><h2><a name="cBasic_Memory_Layout"></a>cBasic Memory Layout<a href="#cBasic_Memory_Layout" class="section_anchor"></a></h2><p>The memory used by a running cBasic simulation is generally a single chunk of memory allocated by the host operating system. The implementation may choose either to use the standard heap-allocation system, or use <a href="http://en.wikipedia.org/wiki/Mmap" rel="nofollow">mmap</a> if a large chunk of memory is needed. </p><p>The lower address of the memory layout contains three segments: code, data, and screen memory. The lowest segment, code, is an array of &quot;cbInstruction&quot; elements, which internally contain an operand (of type &quot;cbOps&quot;) and an integer (of type &quot;int&quot;). The next segment, data, is an array of &quot;cbVariable&quot; followed by string-literals. Each &quot;cbVariable&quot; contains the data type of the variable, and the data itself. Some variables are offsets to the string-literals which are stored at the higher address. If one were to use the &quot;cbDebug_PrintMemory&quot; function, you will get a memory dump of a given cBasic data segment, which may look like the following: </p><p><i>Note: this memory dump comes from &quot;example8.cb&quot;</i> </p><pre class="prettyprint">=== coreBasic Static Memory ===
 Variable Count: 7
 Addr:  [Type    ]  Data

 0000:  [String  ]  112: How many times would you like to loop: 
 0016:  [Integer ]  0
 0032:  [String  ]  152: Only positive numbers please\n
 0048:  [Integer ]  1
 0064:  [String  ]  183: i: 
 0080:  [String  ]  187: \n
 0096:  [Integer ]  1
 0112:  [Raw Data]  48 6f 77 20 6d 61 6e 79 20 74 69 6d 65 73 20 77   How many times w
 0128:  [Raw Data]  6f 75 6c 64 20 79 6f 75 20 6c 69 6b 65 20 74 6f   ould you like to
 0144:  [Raw Data]  20 6c 6f 6f 70 3a 20 00 4f 6e 6c 79 20 70 6f 73    loop: .Only pos
 0160:  [Raw Data]  69 74 69 76 65 20 6e 75 6d 62 65 72 73 20 70 6c   itive numbers pl
 0176:  [Raw Data]  65 61 73 65 5c 6e 00 69 3a 20 00 5c 6e 00 00 00   ease\n.i: .\n...</pre><p>Finally, the last segment on the lower-end of the memory-layout is the screen segment. This screen segment is a direct one-to-one map of a 96 x 64 pixel 2-bit (four colors) gray-scale screen. In total (96*64*2) / 8 = 1536, the screen always is 1536 bytes. The lower address is the top-left corner of the output image, with each growing address being the positive right-hand side of the screen, growing downwards towards the bottom of the screen. </p><p>On the top of the memory-layout, from a high-to-low address growth, is the stack. Each element pushed is an &quot;ibVariable&quot;, which the start of the stack is tracked by the processor&#x27;s register &quot;Stack Pointer&quot;. The &quot;Stack Base Pointer&quot; is the end of the stack, but before the variables loaded for a function frame. </p><h2><a name="cBasic_Instruction_Set"></a>cBasic Instruction Set<a href="#cBasic_Instruction_Set" class="section_anchor"></a></h2><p><i>Note: Subject to change. Each instruction has a unique ID number, but that is not written here nor finalized until the public release of cBasic.</i> </p><h3><a name="Conditional_ops."></a>Conditional ops.<a href="#Conditional_ops." class="section_anchor"></a></h3><ul><li><strong>cbOps_If</strong>: If the top of the stack is true, continues flow of execution, else, jumps to the offset address in the arg </li></ul><h3><a name="Math_ops."></a>Math ops.<a href="#Math_ops." class="section_anchor"></a></h3><ul><li><strong>cbOps_Add</strong>: Add the two top elements from the stack, popping off each, dereferencing any reference variables, and pushing the result to the top of the stack </li><li><strong>cbOps_Sub</strong>: Subtracting the two top elements from the stack, popping off each, dereferencing any reference variables, and pushing the result to the top of the stack </li><li><strong>cbOps_Mul</strong>: Multiplying the two top elements from the stack, popping off each, dereferencing any reference variables, and pushing the result to the top of the stack </li><li><strong>cbOps_Div</strong>: Dividing the two top elements from the stack, popping off each, dereferencing any reference variables, and pushing the result to the top of the stack </li><li><strong>cbOps_Mod</strong>: Computing the remainder between the two top elements from the stack, popping off each, dereferencing any reference variables, and pushing the result to the top of the stack </li></ul><h3><a name="Comparison_algebra_ops."></a>Comparison algebra ops.<a href="#Comparison_algebra_ops." class="section_anchor"></a></h3><ul><li><strong>cbOps_Eq</strong>: Pops off the two top elements and pushes true if they are equal, else pushes a false </li><li><strong>cbOps_NotEq</strong>: Pops off the two top elements and pushes true if they are not equal, else pushes a false </li><li><strong>cbOps_Greater</strong>: Pops off the two top elements and pushes true if the first is greater than the second, else pushes a false </li><li><strong>cbOps_GreaterEq</strong>: Pops off the two top elements and pushes true if the first is greater or equal than the second, else pushes a false </li><li><strong>cbOps_Less</strong>: Pops off the two top elements and pushes true if the first is less than the second, else pushes a false </li><li><strong>cbOps_LessEq</strong>: Pops off the two top elements and pushes true if the first is greater or less than the second, else pushes a false </li></ul><h3><a name="Boolean_ops."></a>Boolean ops.<a href="#Boolean_ops." class="section_anchor"></a></h3><ul><li><strong>cbOps_Not</strong>: Pops off the top element, applying boolean not on it, and pushing the result </li><li><strong>cbOps_And</strong>: Pops off the two top elements from and pushes true if they are both logical-and, otherwise pushes a false </li><li><strong>cbOps_Or</strong>: Pops off the two top elements from and pushes true if they are both logical-or, otherwise pushes a false </li></ul><h3><a name="Program_control_ops."></a>Program control ops.<a href="#Program_control_ops." class="section_anchor"></a></h3><ul><li><strong>cbOps_Goto</strong>: Jumps the flow of execution (i.e. the &quot;Instruction Pointer&quot;) to the given address offset </li><li><strong>cbOps_Stop</strong>: Halts the processor and stops all future execution; this is seen as a &quot;clean-halt&quot;, and <i>not</i> a crash or error </li></ul><h3><a name="Memory_control"></a>Memory control<a href="#Memory_control" class="section_anchor"></a></h3><ul><li><strong>cbOps_Set</strong>: Pops two variables from the stack (A and B), and places A into B, assuming B is a variable, while A can either be a literal or variable </li><li><strong>cbOps_LoadData</strong>: Push data from the data segment into the stack based on the instruction&#x27;s argument, representing an address within that segment. Some data loaded may be literals (i.e. integers), or others may be references (i.e. strings) </li><li><strong>cbOps_LoadVar</strong>: Push the given variable from the stack frame (found after, in higher addresses, from the &quot;Stack Base Pointer&quot;) onto the stack. Note that this variable is always an offset to the original memory location which is at a higher-address location from the &quot;Stack Base Pointer&quot; </li><li><strong>cbOps_AddStack</strong>: Grows the stack (i.e. lowers the &quot;Stack Pointer&quot; variable) by the given number of bytes in the argument of this instruction </li></ul><h3><a name="Input_control"></a>Input control<a href="#Input_control" class="section_anchor"></a></h3><ul><li><strong>cbOps_Pause</strong>: Interrupts the flow of execution until the owning process releases the interrupt using &quot;cbStep_ReleaseInterrupt&quot; </li><li><strong>cbOps_Input</strong>: Interrupts the flow of execution until the owning process releases the interrupt using &quot;cbStep_ReleaseInterrupt&quot; but must also post a string the user has written </li><li><strong>cbOps_GetKey</strong>: Interrupts the flow of execution until the owning process releases the interrupt using &quot;cbStep_ReleaseInterrupt&quot; but must also post a single-char string the user has written (i.e. a single key-stroke) </li></ul><h3><a name="Output_control"></a>Output control<a href="#Output_control" class="section_anchor"></a></h3><ul><li><strong>cbOps_Disp</strong>: Pops a variable from the stack and prints it to the defined output stream </li><li><strong>cbOps_Output</strong>: <i>Not yet defined</i> </li><li><strong>cbOps_Clear</strong>: <i>Not yet defined</i> </li></ul><h3><a name="Function_control"></a>Function control<a href="#Function_control" class="section_anchor"></a></h3><ul><li><strong>cbOps_Exec</strong>: <i>Not yet defined</i> </li><li><strong>cbOps_Return</strong>: <i>Not yet defined</i> </li></ul>

</body>
</html>